<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>servlet学习笔记 | Sunbearls`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.servlet学习笔记1.配置tomcat数据连接池由于HTTP协议的web程序是无状态的，当客户端请求频繁就会消耗很多资源，因此需要配置一种数据库持续连接技术（数据库连接池技术）。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接池，以备其他程序使用。使用tomcat配置数据库连接池有以下两种方式：·配置全局数据库连接池·配置局部数据库连接池配置全局数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="servlet学习笔记">
<meta property="og:url" content="http://yoursite.com/2020/02/06/servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Sunbearls&#96;s Blog">
<meta property="og:description" content="1.servlet学习笔记1.配置tomcat数据连接池由于HTTP协议的web程序是无状态的，当客户端请求频繁就会消耗很多资源，因此需要配置一种数据库持续连接技术（数据库连接池技术）。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接池，以备其他程序使用。使用tomcat配置数据库连接池有以下两种方式：·配置全局数据库连接池·配置局部数据库连接池配置全局数据库">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-06T06:33:53.000Z">
<meta property="article:modified_time" content="2020-02-11T07:37:19.706Z">
<meta property="article:author" content="Mr.luo">
<meta property="article:tag" content="servlet">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Sunbearls`s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Sunbearls`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">about</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-servlet学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/06/servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-02-06T06:33:53.000Z" itemprop="datePublished">2020-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      servlet学习笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="1-servlet学习笔记"><a href="#1-servlet学习笔记" class="headerlink" title="1.servlet学习笔记"></a>1.servlet学习笔记</h2><h3 id="1-配置tomcat数据连接池"><a href="#1-配置tomcat数据连接池" class="headerlink" title="1.配置tomcat数据连接池"></a>1.配置tomcat数据连接池</h3><p>由于HTTP协议的web程序是无状态的，当客户端请求频繁就会消耗很多资源，因此需要配置一种数据库持续连接技术（数据库连接池技术）。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接池，以备其他程序使用。使用tomcat配置数据库连接池有以下两种方式：<br>·配置全局数据库连接池<br>·配置局部数据库连接池<br>配置全局数据库连接池的方式如下：</p>
<span id="more"></span>
<p>1）在tomcat安装目录下的&#x2F;conf&#x2F;server.xml文件中找到GlobalNamingResources标签，并加入一个子标签Resoutce，这个子标签的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Resource name=<span class="string">&quot;jdbc/webdb&quot;</span>   &lt;!--设置位置源名称，通常为“jdbc/xxxx”--&gt;</span><br><span class="line">          auth=<span class="string">&quot;Container&quot;</span>    &lt;!--设置数据源的管理者，有两个选项（Container和Application）前者表示由容器来管理和创建数据源，后者表示由Web应用来创建和管理数据源--&gt;</span><br><span class="line">          <span class="built_in">type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span>  &lt;!--设置数据源的类型--&gt;</span><br><span class="line">          username=<span class="string">&quot;root&quot;</span>   &lt;!--数据库的登陆名--&gt;</span><br><span class="line">          password=<span class="string">&quot;xxxxxxx&quot;</span>   &lt;!--数据库登录密码--&gt;</span><br><span class="line">          maxIdle=<span class="string">&quot;50&quot;</span>       &lt;!-最大空闲连接数--&gt;</span><br><span class="line">          maxWaitMillis=<span class="string">&quot;10000&quot;</span>   &lt;!--暂时无法获取数据库连接的等待时间，mysql版本在8.0之前此值为maxWait--&gt;</span><br><span class="line">          maxTotal=<span class="string">&quot;200&quot;</span>    &lt;!--连接池可以存储的最大数，mysql版本在8.0之前为maxActive--&gt;</span><br><span class="line">          driverClassName=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>    &lt;!--指定mysql的驱动类名，mysql8.0之前为driverClassName=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>--&gt;</span><br><span class="line">          url=<span class="string">&quot;jdbc:mysql://localhost:3308/webdb?characterEncoding=utf8&amp;amp;rewriteBatchedStatements=true&amp;amp;serverTimezone=UTC&amp;amp;useSSL=FALSE&quot;</span> /&gt;   &lt;!--指定连接字符串，mysql8.0之前可以没有useSSL=FALSE和serverTimezone=UTC属性--&gt;</span><br></pre></td></tr></table></figure>
<p>2）在tomcat安装目录下的&#x2F;conf&#x2F;context.xml文件中加入以下代码引用全局资源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ResourceLink name=<span class="string">&quot;jdbc/webdb&quot;</span> global=<span class="string">&quot;jdbc/webdb&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span>/&gt; </span><br></pre></td></tr></table></figure>
<p>3）在项目中的WEB-INF\web.xml中加入以下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resource-ref&gt;</span><br><span class="line">  &lt;description&gt;mysql数据库资源池&lt;/description&gt;</span><br><span class="line">  &lt;res-ref-name&gt;jdbc/webdb&lt;/res-ref-name&gt;</span><br><span class="line">  &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;</span><br><span class="line">  &lt;res-auth&gt;Container&lt;/res-auth&gt;</span><br><span class="line">  &lt;res-sharing-scope&gt;Shareable&lt;/res-sharing-scope&gt;</span><br><span class="line">&lt;/resource-ref&gt;</span><br></pre></td></tr></table></figure>
<p>这样便完成了全局数据库连接池xml文件的配置，完成以上操作后需要将需要的jar包加入tomcat安装文件下的lib文件夹下。<br>如若需要在eclipse中配置数据库资源池，需要在META-INF文件下新建context.xml文件，然后在文件中加入第一步的代码即可。如果不加入此文件运行eclipse servlet时会出现cannot create resource instance这样的报错。<br>使用如下代码来实现对数据库资源池的调用,亲测有用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package chapter4;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Servlet implementation class ViewDictionary</span><br><span class="line"> */</span><br><span class="line">@WebServlet(<span class="string">&quot;/ViewDictionary&quot;</span>)</span><br><span class="line">public class ViewDictionary extends HttpServlet &#123;</span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @see HttpServlet<span class="comment">#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">	 */</span><br><span class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException</span><br><span class="line">	&#123;</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">		PrintWriter out = response.getWriter();</span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			Context ctx = new InitialContext();</span><br><span class="line">			// 根据webdb数据源获得DataSource对象</span><br><span class="line">			javax.sql.DataSource ds = (javax.sql.DataSource) ctx</span><br><span class="line">					.lookup(<span class="string">&quot;java:/comp/env/jdbc/webdb&quot;</span>);</span><br><span class="line">			Connection conn = ds.getConnection();</span><br><span class="line">			// 执行SQL语句</span><br><span class="line">			PreparedStatement pstmt = conn</span><br><span class="line">					.prepareStatement(<span class="string">&quot;SELECT * FROM t_dictionary&quot;</span>);</span><br><span class="line">			ResultSet rs = pstmt.executeQuery();</span><br><span class="line">			StringBuilder table = new StringBuilder();</span><br><span class="line">			table.append(<span class="string">&quot;&lt;table border=&#x27;1&#x27;&gt;&quot;</span>);</span><br><span class="line">			table.append(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;书名&lt;/td&gt;&lt;td&gt;价格&lt;/td&gt;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span> (rs.next()) // 生成查询结果</span><br><span class="line">			&#123;</span><br><span class="line">				table.append(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> + rs.getString(<span class="string">&quot;english&quot;</span>) + <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>);</span><br><span class="line">				table.append(rs.getString(<span class="string">&quot;chinese&quot;</span>) + <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			table.append(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span><br><span class="line">			out.println(table.toString()); // 输出查询结果</span><br><span class="line"></span><br><span class="line">			pstmt.close();  // 关闭PreparedStatement对象</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-处理客户端HTTP-GET请求（doGet方法）"><a href="#2-处理客户端HTTP-GET请求（doGet方法）" class="headerlink" title="2.处理客户端HTTP GET请求（doGet方法）"></a>2.处理客户端HTTP GET请求（doGet方法）</h3><p>在HttpServlet中提供了一组doXxx方法，可以通过这些方法处理各种HTTP请求，doget方法可以处理get请求，方法定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException,IOEexception</span><br></pre></td></tr></table></figure>
<h3 id="3-处理客户端http-post请求（doPost方法"><a href="#3-处理客户端http-post请求（doPost方法" class="headerlink" title="3.处理客户端http post请求（doPost方法)"></a>3.处理客户端http post请求（doPost方法)</h3><p>doPost方法的定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void doPost(HttpServletRequest req,HttpServletResponse resp)throws ServletException,IOException</span><br></pre></td></tr></table></figure>
<p>当我们在servlet中写好doPost函数时，需要在html文件中写一个表单标签来创建一个action来运行，直接运行会出现HTTP method GET is not supported by this URL这样的错误。</p>
<h3 id="4-处理客户端的各种请求（service方法）"><a href="#4-处理客户端的各种请求（service方法）" class="headerlink" title="4.处理客户端的各种请求（service方法）"></a>4.处理客户端的各种请求（service方法）</h3><p>虽然可以在doPost中调用doGet方法来实现同时处理HTTP GET和HTTP POST请求，但是这样比较麻烦，因此我们使用HttpServlet类的service方法，此方法可以根据HTTP协议的请求方式调用不同的doXxx方法</p>
<h3 id="5-初始化（init）和销毁-destroy"><a href="#5-初始化（init）和销毁-destroy" class="headerlink" title="5.初始化（init）和销毁(destroy)"></a>5.初始化（init）和销毁(destroy)</h3><p>当servlet对象实例被web服务器第一次创建时，会调用HttpSrevlet类中的init方法，我们可以在这个方法中实现初始化servlet的功能，当web服务器销毁servlet对象实例时，会调用HttpServlet类的destroy方法，可以在这个函数中释放由Servlet所占用的各种资源。这两个函数在servlet的整个生命周期中都只调用一次。</p>
<h3 id="6-向客户端输出字符流相应消息-PrintWriter类"><a href="#6-向客户端输出字符流相应消息-PrintWriter类" class="headerlink" title="6.向客户端输出字符流相应消息-PrintWriter类"></a>6.向客户端输出字符流相应消息-PrintWriter类</h3><p>我们可以使用PrintWriter对象向客户端输出消息，我们可以通过HttpServletResponse类的getWriter方法获得PrintWriter类的对象实例，在具体此对象时我们应该注意以下几点：<br>·当通过HttpServletRequest类的getWriter方法获取PrintWriter类对象之前，需要使用setContentType方法设置Content-Type字段值，否则setContentType方法不起作用<br>·HttpServletResponse类的addHeader和setHeader方法用来进行响应头的设置，可以在调用getWriter方法前后使用<br>·虽然可以使用addHeader和setHeader方法在调用getWriter方法后设置Content-Type字段的值，当时我们在getWriter方法之后调用setContentType方法设置响应信息的字符集编码，在客户端浏览器中的的中文信息仍然会显示“？”乱码。</p>
<h3 id="7-向客户端输出字节流相应消息-ServletOutputStream类"><a href="#7-向客户端输出字节流相应消息-ServletOutputStream类" class="headerlink" title="7.向客户端输出字节流相应消息-ServletOutputStream类"></a>7.向客户端输出字节流相应消息-ServletOutputStream类</h3><p>当服务器向客户端输出字节消息（图像、视频等），此时需要使用ServletOutputStream类，可以通过HttpServletResponse类中的getOutputStream方法获得ServletOutputStream对象实例。<br>getOutputStream和getWriter方法不能同时使用，不然会报错。</p>
<h3 id="8-包含web资源和转发web资源"><a href="#8-包含web资源和转发web资源" class="headerlink" title="8.包含web资源和转发web资源"></a>8.包含web资源和转发web资源</h3><p>1）包含web资源RequestDispatcher.include方法<br>包含web资源是为了实现代码重用，将一些公用的代码和数据放入到一个或者几个servlet中，可以使用RequestDispatcher.include方法，首先通过getServletContext方法获取ServletCOntext对象，然后通过ServletContext.getRequestDispatcher方法获取RequestDispatcher对象。具体实现如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher rd = getServletContext().getRequestDispatcher(<span class="string">&quot;servlet文件映射路径&quot;</span>)；</span><br><span class="line">rd.include(request,response);</span><br></pre></td></tr></table></figure>
<p>getRequestDispatcher方法的参数必须以“&#x2F;”开头,使用此方法的url仍然是调用servlet文件的url,这是因为使用include方法相当于servlet引擎在调用者的service方法中又调用了被调用者的service方法，并将调用者的service方法的两个参数传入了被调用者的sercvice方法。<br>2）转发web资源RequestDispatcher.forward方法<br>转发web资源和包含web资源很相似，但是这两种方法有以下5点不同：<br>·在调用forward方法之前，输出缓冲区中的数据会被清空，在使用方法此进行转发时，只可能输出被转发的web资源中的消息。<br>·如果在调用forward之前，已经将缓冲区中的数据转发到客户端，在调用forward方法时会抛出IllegalStateException异常，这个异常会在tomcat控制台或者是在eclipse的console中显示，而在ie浏览器中仍然会输出已经发送过来的消息。<br>·在调用者和被调用者中设置响应消息头都不会被忽略，而调用include方法时，只有在调用者中设置响应消息头才会生效。<br>·Servlet引擎会根据RequestDispatcher对象所包含的的资源对HttpServletRequest对象中的请求路径和参数消息进行调整。而使用include方法时servlet引擎并不调整这个消息。<br>·forward方法只能使用一次，否则会抛出IllegalStateException异常，而include方法可以多次使用。<br>下面的代码是使用forward方法的使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher rd = getServletContext().getRequestDispatcher(<span class="string">&quot;servlet文件映射路径&quot;</span>)；</span><br><span class="line">rd.forward(request,response);</span><br></pre></td></tr></table></figure>
<p>使用此方法在被转入的web资源中改变了servlet的请求路径</p>
<h2 id="2-HttpServletResponse类"><a href="#2-HttpServletResponse类" class="headerlink" title="2.HttpServletResponse类"></a>2.HttpServletResponse类</h2><h3 id="1-产生状态响应码"><a href="#1-产生状态响应码" class="headerlink" title="1.产生状态响应码"></a>1.产生状态响应码</h3><p>当客户端请求服务器之后，服务端就会将返回的信息封装到类HttpServletResponse里进行响应。具体格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 2000 OK</span><br></pre></td></tr></table></figure>
<p>上面的状态行分为3部分，分别是HTTP版本、状态响应码和状态消息。HTTP的状态响应码为3为整数，共分为以下五类：<br>·100-199：表示服务器端已经成功接受请求，但是需要客户端继续提交下一次请求才能完成全部处理过程<br>·200-299：表示服务器端已经成功接受请求，并完成了所有的处理过程<br>·300-399：表示客户端请求的资源已经移到了别的位置，并向客户提供了一个新的地址，一般这个新的地址有HTTP响应报头的location字段指定<br>·400-499：表示客户端的请求有误<br>·500-599：表示服务器端出现错误<br>HttpServletResponse类中有以下的方法设置状态码：<br>1）设置状态响应码-setStatus方法<br>setStatus()方法可以设置任何HTTP响应消息的状态响应码，并生成相应状态行，由于响应状态行中的版本和状态消息是由服务器决定的，因此只设定响应状态码就行了，setStatus()方法的定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void setStatus(int sc);</span><br></pre></td></tr></table></figure>
<p>其中sc表示状态响应码，它可以直接使用整数形式，也可以使用在HttpServletReponse中的定义的常量。<br>2）302状态响应码的应用-sendRedirect方法<br>HttopServletResponse中提供了一个sendRedirect方法来设置响应状态码302，该状态码可以将事项客户端重定向到URL，此方法的定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void sendRedirect(String location) throws IOException;</span><br></pre></td></tr></table></figure>
<p>通过此方法可以将当前的servlet重定向到其他的url上，此url可以是绝对也可以是相对的<br>3）400~599状态码的应用-sendError方法<br>sendError方法用于发送表示错误消息的状态响应码，而且还可以设置状态消息，其定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void sendError(int sc) throws IOException;</span><br><span class="line">public void sendError(int sc,string msg) throws IOException;</span><br></pre></td></tr></table></figure>
<p>其中sc表示状态响应码，msg表示状态消息</p>
<h3 id="2-设置响应消息头"><a href="#2-设置响应消息头" class="headerlink" title="2.设置响应消息头"></a>2.设置响应消息头</h3><p>当客户端请求服务器之后，服务器会将返回信息封装到类HttpServletRespnse里进行响应，返回信息中状态行下面的内容就是响应消息头，是HTTP响应消息的重要组成部分，标准的响应消息头如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-length:12903</span><br><span class="line">Content-Type:text/html</span><br><span class="line">Content-Location:http://www.xxxxx.com</span><br><span class="line">Last-Modified:Tue,25 Dec 2007 11:3:06 GTM</span><br><span class="line">Accept-Ranges:bytes</span><br><span class="line">Server:Microsoft-IIS/6.0</span><br><span class="line">X-Power-By:ASP.NET </span><br><span class="line">Date:Tue,25 Dec 2007 11:3:06 GMT</span><br></pre></td></tr></table></figure>
<p>当servlet向客户端发送响应消息时，为了达到某些目的，需要对某些响应消息头进行设置。<br>1.添加和设置响应消息头-addHeader和setHeader方法<br>这两个方法可以设置HTTP响应消息头的所有字段，他们定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void addHeader(String name ,String value);</span><br><span class="line">public void setHeader(String name ,String value);</span><br></pre></td></tr></table></figure>
<p>其中name表示响应消息头的字段名，value表示相应消息头的字段值，这两个方法都可以增加一个字段，他们不同之处是如果name字段已经存在，setHeader方法会用value来覆盖旧的字段，而addHeader方法会增加一个同名的字段。</p>
<p>2.操作整数类型的响应消息头-addIntHeader与setIntHeader方法<br>HttpServletResponse提供了两个专门设置整型字段值的方法，他们的定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void addIntHeader(String name,int value);</span><br><span class="line">public void setIntHeader(String name ,int value);</span><br></pre></td></tr></table></figure>
<p>这两个方法与setHeader和addHeader方法的用法类似，他们在设置整型字段值时避免了将int类型转换为String类型值的麻烦</p>
<p>3.操作时间类型的响应消息头-addDataHeader与setDataHeader方法<br>HttpServletReponse提供了两个专门设置日期字段值的方法，他们的定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void addDataHeader(String name ,long <span class="built_in">date</span>);</span><br><span class="line">public void setDataHeader(String name ,long <span class="built_in">date</span>);</span><br></pre></td></tr></table></figure>
<p>这两个方法和setHeader及addHeade方法的用法类似。HTTP响应头中的日期一般为GMT时间格式。</p>
<p>4.设置响应正文类型的响应消息头-content-Type<br>setContentType方法用于设置Servlet的响应正文的MIME类型，对于HTTP协议来说，就是设置Content-Type字段的值，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.serContentType(<span class="string">&quot;image/jpeg&quot;</span>);  //设置响应正文类型的响应消息头</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);  //设置响应正文字符集</span><br></pre></td></tr></table></figure>

<p>5.设置响应正文字大小的响应消息头-Content-Length<br>setContentLength方法用于设置相应正文的大小（单位是字节）。一般来说，在servlet中并不需要使用setContentLength方法设置ContentType的值，因为Servlet引擎会自动根据向客户端实际输出的响应正文大小自动设置ContentLength字段的值。</p>
<p>6.检查响应消息头-containsHeader方法<br>containsHeader方法用于检查某个字段名是否在响应消息头中存在，如果存在，返回true,否则返回false.containsHeader方法的定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsHeader(String name);</span><br></pre></td></tr></table></figure>

<h3 id="3-验证响应消息头设置情况"><a href="#3-验证响应消息头设置情况" class="headerlink" title="3.验证响应消息头设置情况"></a>3.验证响应消息头设置情况</h3><p>响应消息头是HTTP响应消息中非常重要的部分，可以实现很多重要的功能，在编程时需要特别小心，因为代码位置不同，响应消息头的作用也不同。以下代码通过HttpServletResponse来设置HTTP响应消息头。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);  //设置Content-Content字段的值</span><br><span class="line">		response.setHeader(<span class="string">&quot;Content-Length&quot;</span>, <span class="string">&quot;1234&quot;</span>);  </span><br><span class="line">		response.setHeader(<span class="string">&quot;newfield&quot;</span>, <span class="string">&quot;value1&quot;</span>);   //加一个newfield字段</span><br><span class="line">		Calendar cal = Calendar.getInstance();   //获得calendar对象</span><br><span class="line">		cal.set(2008, 11,25);</span><br><span class="line">		response.addDateHeader(<span class="string">&quot;mydate&quot;</span>, cal.getTimeInMillis());  //加一个mydate字段</span><br><span class="line">		response.setIntHeader(<span class="string">&quot;newfield2&quot;</span>, 3000);  //加一个newfield2字段</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们在此servlet文件运行之后，可以通过工具查看HTTP响应消息头</p>
<h2 id="3-HttpServletRequest类"><a href="#3-HttpServletRequest类" class="headerlink" title="3.HttpServletRequest类"></a>3.HttpServletRequest类</h2><h3 id="1-获取请求行消息"><a href="#1-获取请求行消息" class="headerlink" title="1.获取请求行消息"></a>1.获取请求行消息</h3><p>HTTP请求消息分为三个部分，分别是请求行、请求消息头、消息正文，客户端在请求某一个servlet时，servlet引擎会为这个servlet创建一个HttpServletRequest对象来存储客户端的请求消息，并在调用service方法时将HttpServletRequest对象作为参数传给了service方法<br>请求行分为三个部分：请求方式（get\post\head）、资源路径、HTTP协议版本，具体格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /webdome/servlet/HelloWrold HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>HttpServletRequest接口中定义了若干方法来获取请求中各部分的消息，如下表</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="center">功能</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getMethod</td>
<td align="center">返回请求消息行中的请求方法，（如GET\POST\HEAD\PUT\DELETE等）</td>
<td align="left">GET</td>
</tr>
<tr>
<td align="left">getRequestRUI</td>
<td align="center">返回请求行中的资源部分（不包括参数部分）</td>
<td align="left">&#x2F;webdome&#x2F;servlet</td>
</tr>
<tr>
<td align="left">getQueryString</td>
<td align="center">返回请求行中的参数部分，也就是资源路径后的“？”开头后面的部分，若果没有则返回null</td>
<td align="left">name&#x3D;bill&amp;age&#x3D;52</td>
</tr>
<tr>
<td align="left">getProtocol</td>
<td align="center">返回请求行中的协议部分</td>
<td align="left">HTTP&#x2F;1.1</td>
</tr>
<tr>
<td align="left">getContextPath</td>
<td align="center">返回web应用程序的上下文路径，实际上就是COntent标签中的path属性的值，如果web文件处于根目录则返回空字符串（””）</td>
<td align="left">&#x2F;webdome</td>
</tr>
<tr>
<td align="left">getPathInfo</td>
<td align="center">返回额外的路径部分。额外路径位于资源路径和参数之间，以”&#x2F;“开头。</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">getPathTranslated</td>
<td align="center">获得额外路径在服务端的本地路径，如没有额外路径则返回null</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">getServletPath</td>
<td align="center">返回web.xml中的url-pattern标签定义的Servlet映射路径</td>
<td align="left">&#x2F;servlet&#x2F;HelloWorld</td>
</tr>
<tr>
<td align="left">getParameter</td>
<td align="center">返回某一个参数的值，如获得name参数值得代码是getParameter(“name”)</td>
<td align="left">bill</td>
</tr>
</tbody></table>
<h3 id="2-获取网络连接消息"><a href="#2-获取网络连接消息" class="headerlink" title="2.获取网络连接消息"></a>2.获取网络连接消息</h3><p>以下是HttpServletRequest接口中,用于获得客户端和服务器与网络连接有关的信息的方法：</p>
<p>| 方法名|功能|返回值<br>| getRemoteAddr | 返回客户机用于发送请求的IP地址 | 客户机的ip |<br>| getRemoteHost | 返回发出请求的客户机的主机名。如果servlet引擎不能解析出客户机的主机名，返回客户机的ip | 客户机的主机名 |<br>| getRemotePort | 返回客户机所使用的端口号 | 请求端口号 |<br>| getLocalAddr | 返回web服务器上接收请求的网络接口使用的IP地址 | 服务器的ip地址 |<br>| getLocalName | 返回web服务器上接受请求的网络接口的IP地址所对应的主机名 | 返回服务器主机名 |<br>| getLocalPort | 返回web服务器上接收请求的网络接口的端口号 | 8080 |<br>| getServerName | 返回HTTP请求消息的HOST字段的主机名部分 | localhost |<br>| getServerPort | 返回HTTP请求消息的HOST字段的端口号部分 | 8080 |<br>| getScheme | 返回请求的协议名，如http\https等 | http |<br>| getRequestURL | 返回完整的请求URL（不包括参数部分)，这个方法返回的是StringBuffer类型，而不是String | <a target="_blank" rel="noopener" href="http://localhost:8080/webdomo/xxx">http://localhost:8080/webdomo/xxx</a> |</p>
<h3 id="3-获取请求头消息"><a href="#3-获取请求头消息" class="headerlink" title="3.获取请求头消息"></a>3.获取请求头消息</h3><p>HttpServletRequest中定义了很多方法来获取请求消息的请求头，如下表：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="center">功能</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getHeader</td>
<td align="center">返回指定的HTTP请求消息头字段的值，如获得Host字段值的代码为getHeader(“Host”)</td>
<td align="left">localhost:8080</td>
</tr>
<tr>
<td align="left">getHeaders</td>
<td align="center">返回重名头字段的所有值。这个方法返回的是一个java.util.Enumeration集合对象</td>
<td align="left">由所有重复字段的值组成</td>
</tr>
<tr>
<td align="left">getHeaderNames</td>
<td align="center">返回一个包含HTTP请求消息中的所有头字段名的Enumeration对象</td>
<td align="left">所有的字段名</td>
</tr>
<tr>
<td align="left">getIntHeader</td>
<td align="center">返回一个指定的头字段的值，并将其转换为整形</td>
<td align="left">整数</td>
</tr>
<tr>
<td align="left">getDateHeader</td>
<td align="center">返回一个指定的头字段的值，并将其按照GMT时间转换为一个长整型的值</td>
<td align="left">长整数</td>
</tr>
<tr>
<td align="left">getContentType</td>
<td align="center">返回请求消息中请求正文的内容类型</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">getContentLength</td>
<td align="center">返回请求消息中请求正文的长度。如果未指定长度，则返回-1</td>
<td align="left">-1</td>
</tr>
<tr>
<td align="left">getCharacterEncoding</td>
<td align="center">返回请求正文的字符集编码，如果未指定字符集编码返回null</td>
<td align="left">null</td>
</tr>
</tbody></table>
<h2 id="4-处理Cookie"><a href="#4-处理Cookie" class="headerlink" title="4.处理Cookie"></a>4.处理Cookie</h2><p>cookie是一种在客户端保存信息的技术。cookie是在浏览器访问某个web资源时，由web服务器在HTTP响应消息头中通过Set-Cookie字段发送给浏览器的一组消息。浏览器会根据Set-Cookie中的Cookie数据决定是否保存这些Cookie。一个Cookie只能表示一个key-value对，这个key-value队由Cookie名和Cookie值组组成。</p>
<h3 id="1-操作Cookie的方法"><a href="#1-操作Cookie的方法" class="headerlink" title="1.操作Cookie的方法"></a>1.操作Cookie的方法</h3><p>在servlet API中，使用java.servlet.http.cookie类来封装一个Cookie消息，在HttpServlet接口中定义了一个addCookie方法来向浏览器发送Cookie消息，在HttpServletRequest接口中定义了一个getCookies方法来获取浏览器传递过来的Cookie消息。Cookie类只有一个构造方法，其定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Cookie(String name ,String value)</span><br></pre></td></tr></table></figure>
<p>其中name表示Cookie名（在name值中不能包含任何字符、逗号、分号、并且不能以$开头），value表示Cookie值，Cookie类中的其他常用方法如下所示：<br>·getName方法:该方法用于返回Cookie的名称<br>·setValue和getValue方法：这两个人方法分别用于设置和返回Cookie的值<br>·setMaxAge和getMaxAge方法：这两个方法分别用于设置和返回Cookie在客户机的有效时间，也就是Cookie在客户机上的的有效秒数。如果设置为0表示当Cookie消发送到客户端立即被删除，如果为负数，表示浏览器不会把此Cookie保存在硬盘上，这种Cookie称为临时Cookie。<br>·setPath和getPath方法：这两个方法分别用于设置和返回当前Cookie的有效web路径。如果在创建某个Cookie时未设置它的path属性，那么该Cookie只对当前访问的Servlet所在的web路径及其子路径有效。如果想使Cookie对web站点中的所有可访问的路径都有效，需要将path路径设置为”&#x2F;“<br>·setDomain和getDomain:这两个方法分别用于设置和返回当前Cookie的有效域。<br>·setComment和getComment:这两个方法分别用于设置和返回当前Cookie的注释部分<br>·setVersion和getVersion：这两个方法分别用于设置和返回当前Cookie的协议版本<br>·setSecure和getSecure：这两个方法分别用于设置和返回当前Cookie是否只能使用安全的协议传输Cookie</p>
<h2 id="4-处理Session"><a href="#4-处理Session" class="headerlink" title="4.处理Session"></a>4.处理Session</h2><p>session是一种将信息保存在服务端的技术。session可以大量的数据保存在在服务端，并使用SessionID对这些数据进行追踪。session是为了解决当数据量非常大的时候，Cookie在客户端和服务器端频繁传送而浪费大量的带宽。在servlet中使用HttpSession类来描述Session，一个HttpSession的对象就是一个Session。使用HttpServletRequest接口中的getSession方法可以获得一个HttpSession对象。</p>
<h3 id="1-操作Session的方法"><a href="#1-操作Session的方法" class="headerlink" title="1.操作Session的方法"></a>1.操作Session的方法</h3><p>·getID方法：该方法用于返回当前HttpSession对象的SessionID，由于Session是由Servlet引擎自动生成的，因此不需要利用setID方法来设置这个SessionID。<br>·getCreationTime方法:该方法用于返回当前HttpSession对象的创建时间，，返回的时间是一个自1970年1月1日的0点0分0秒开始计算的毫秒数<br>·getLastAccessedTime方法：该方法用于返回当前HttpSession对象的上一次被访问的时间，返回的时间格式是一个自1970年1月1日的0点0分0秒开始计算的毫秒数<br>·setMaxInactiveInterval和getMaxInactiveInterval方法：这两个方法分别用来设置和返回当前HttpSession对象可空闲的最长时间，这个时间也就是当前会话的有效时间，当某个HttpSession对象在超过这个最长时间后仍然没有被访问时，该HttpSession对象就会失败，整个会话过程就会结束，如果有效时间被设置成负数，则表示会话在当前web应用程序结束之前永远有效<br>·isNew方法：该方法用来判断当前的HttpSession对象是否是新创建，如果是，则返回true,否则返回false.<br>·isvalidate方法：该方法用于强制当前的HttpSession对象失效，这样web服务器可以立即释放该HttpSession对象。在不需要使用某个HttpSession对象时，建议使用此方法释放资源。<br>·getServletContent方法：该方法用于返回当前HttpSession对象所属的web应用程序的ServletContent对象。这个方法和GenericServlet的getSercletContent方法返回的是同一个ServletContext对象<br>·setAttribute方法：该方法用于将一个String类型的的ID和一个对象相关联，并将其保存在当前的HttpSession对象中。如果用setAttribute方法保存了一个实现HttpSessionBindingListener接口类的对象，那么系统将自动调用HttpSessionBindingListener接口的valueBound方法。<br>·getAttribute方法：该方法用于返回一个和String类型的ID相关联的对象。setAttribute和getAttribute方法相当于向一个HashMap对象中增加key-value对，以及根据key检索value<br>·remoteAttribute方法:该方法用于删除一个与String类型的ID下相关联的对象。当这个对象的类实现HttpSessionBindingListener接口时，如果调用该类的remoteAttribute方法，那么系统将自动调用HttpSessionBindingListener接口的valueUnbound方法，除了调用remoteAttribute方法时会调用HttpSessionBindingListener接口的valueUnbound方法外，当调用invalidate方法使当前HttpSession对象失效时，或使用setAttribute方法添加一个ID和对象（但这个ID已经存在），并且这个对象和已经存在的ID所关联的对象不同时，系统也会调用HttpSessionBindinglistener接口的valueUnbound方法。<br>·getAttributeNames方法：该方法用于返回一个当前HttpSession对象中所有的属性名的Enumeration对象。可以利用这个方法获得保存在HttpSession对象中的所有属性名。</p>
<h3 id="2-创建Session对象"><a href="#2-创建Session对象" class="headerlink" title="2.创建Session对象"></a>2.创建Session对象</h3><p>一个请求只能属于一个Session，但一个Session也可以拥有多个请求。HttpServletRequest接口中定义了一些与Session相关的方法，其中getSession方法用于返回与当前请求相关的HttpSession对象，此方法有两种重载形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public HttpSession getSession();</span><br><span class="line">public HttpSession getSession(boolean create);</span><br></pre></td></tr></table></figure>
<p>调用第一种方法时，如果在请求消息中含有SessionID就根据这个SessionID返回一个HttpSession对象，如果没有则创建一个新的HttpSession对象，并返回它。第二种形式如果参数为true，则与第一种相同，如果为false，在请求中不包含SessionID时，返回null,并不会创建一个新的HttpSession对象。</p>
<p>HttpServletRequest接口中其他和Session相关的方法：<br>·isRequestedSessionIdValid方法：当请求消息中包含的SessionID所指向的HttpSession对象已经超过了最大空闲时间间隔，此方法返回false，否则返回true（当请求消息中不包含SessionID时，此方法返回false)<br>·isRequestedSessionFromCookie方法：该方法用于判断SessionID是否通过HTTP请求信息中的Cookie字段传递过来<br>·isRequestedSessionFromURL方法：该方法用于判断SessionID是否通过HTTP请求消息的URL参数传递过来的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/06/servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl9r8y4xk00197c792brccw36" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/02/06/navicat%E8%BF%9E%E6%8E%A5mysql%E9%97%AE%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          navicat连接mysql问题
        
      </div>
    </a>
  
  
    <a href="/2020/02/04/AJAX%E5%AD%A6%E4%B9%A0%E7%AC%94%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">AJAX学习笔笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">问题解决</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AJAX/" rel="tag">AJAX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E4%BD%BF%E7%94%A8/" rel="tag">hexo使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%AD%A6%E4%B9%A0/" rel="tag">linux学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/navicat/" rel="tag">navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E4%B9%B1%E7%A0%81/" rel="tag">web乱码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AJAX/" style="font-size: 10px;">AJAX</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/hexo%E4%BD%BF%E7%94%A8/" style="font-size: 20px;">hexo使用</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/linux%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">linux学习</a> <a href="/tags/navicat/" style="font-size: 10px;">navicat</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/web%E4%B9%B1%E7%A0%81/" style="font-size: 10px;">web乱码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/19/llinux%E5%AD%A6%E4%B9%A0/">llinux学习</a>
          </li>
        
          <li>
            <a href="/2022/08/18/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/02/11/web%E5%BC%80%E5%8F%91%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/">web开发乱码问题</a>
          </li>
        
          <li>
            <a href="/2020/02/06/navicat%E8%BF%9E%E6%8E%A5mysql%E9%97%AE%E9%A2%98/">navicat连接mysql问题</a>
          </li>
        
          <li>
            <a href="/2020/02/06/servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">servlet学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Mr.luo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">about</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>